{"ast":null,"code":"// Algoritmo K-means para clustering de comportamentos orçamentários\n\n// Calcula distância euclidiana entre dois pontos\nconst euclideanDistance = (p1, p2) => {\n  return Math.sqrt(Math.pow(p1.deviation - p2.deviation, 2) + Math.pow(p1.executionRate - p2.executionRate, 2));\n};\n\n// Algoritmo K-means\nexport const kMeansClustering = (points, k = 4, maxIterations = 100) => {\n  // Normaliza os dados (0-1) para melhor clustering\n  const deviations = points.map(p => p.deviation);\n  const executionRates = points.map(p => p.executionRate);\n  const minDev = Math.min(...deviations);\n  const maxDev = Math.max(...deviations);\n  const minExec = Math.min(...executionRates);\n  const maxExec = Math.max(...executionRates);\n  const normalizedPoints = points.map(p => ({\n    ...p,\n    normDeviation: (p.deviation - minDev) / (maxDev - minDev || 1),\n    normExecutionRate: (p.executionRate - minExec) / (maxExec - minExec || 1)\n  }));\n\n  // Inicializa centroides (k-means++)\n  const centroids = [];\n\n  // Primeiro centroide aleatório\n  const firstPoint = normalizedPoints[Math.floor(Math.random() * normalizedPoints.length)];\n  centroids.push({\n    deviation: firstPoint.normDeviation,\n    executionRate: firstPoint.normExecutionRate\n  });\n\n  // Próximos centroides: escolhe pontos mais distantes\n  for (let i = 1; i < k; i++) {\n    const distances = normalizedPoints.map(p => {\n      const minDist = Math.min(...centroids.map(c => euclideanDistance({\n        deviation: p.normDeviation,\n        executionRate: p.normExecutionRate\n      }, c)));\n      return minDist;\n    });\n    const maxDistIndex = distances.indexOf(Math.max(...distances));\n    centroids.push({\n      deviation: normalizedPoints[maxDistIndex].normDeviation,\n      executionRate: normalizedPoints[maxDistIndex].normExecutionRate\n    });\n  }\n\n  // Iterações K-means\n  let assignments = new Array(points.length).fill(0);\n  for (let iter = 0; iter < maxIterations; iter++) {\n    // Atribui pontos aos clusters mais próximos\n    const newAssignments = normalizedPoints.map(p => {\n      const distances = centroids.map(c => euclideanDistance({\n        deviation: p.normDeviation,\n        executionRate: p.normExecutionRate\n      }, c));\n      return distances.indexOf(Math.min(...distances));\n    });\n\n    // Verifica convergência\n    if (JSON.stringify(assignments) === JSON.stringify(newAssignments)) {\n      break;\n    }\n    assignments = newAssignments;\n\n    // Recalcula centroides\n    for (let i = 0; i < k; i++) {\n      const clusterPoints = normalizedPoints.filter((_, idx) => assignments[idx] === i);\n      if (clusterPoints.length > 0) {\n        centroids[i] = {\n          deviation: clusterPoints.reduce((sum, p) => sum + p.normDeviation, 0) / clusterPoints.length,\n          executionRate: clusterPoints.reduce((sum, p) => sum + p.normExecutionRate, 0) / clusterPoints.length\n        };\n      }\n    }\n  }\n\n  // Nomeia e caracteriza clusters baseado nos centroides\n  const clusterInfos = centroids.map((centroid, idx) => {\n    const avgDeviation = centroid.deviation * (maxDev - minDev) + minDev;\n    const avgExecution = centroid.executionRate * (maxExec - minExec) + minExec;\n    let name = '';\n    let description = '';\n    let color = '';\n    if (avgDeviation > 10 && avgExecution > 80) {\n      name = 'Expansão com Alta Execução';\n      description = 'Anos com aumento orçamentário e execução eficiente';\n      color = '#10b981'; // Verde\n    } else if (avgDeviation > 10 && avgExecution <= 80) {\n      name = 'Expansão com Subexecução';\n      description = 'Anos eleitorais com aumento de verba mas execução baixa';\n      color = '#f59e0b'; // Amarelo\n    } else if (avgDeviation < -10) {\n      name = 'Crise/Corte';\n      description = 'Períodos de redução orçamentária significativa';\n      color = '#ef4444'; // Vermelho\n    } else {\n      name = 'Comportamento Normal';\n      description = 'Execução dentro da normalidade estatística';\n      color = '#3b82f6'; // Azul\n    }\n    return {\n      name,\n      description,\n      color\n    };\n  });\n\n  // Cria clusters finais\n  return centroids.map((centroid, idx) => {\n    const clusterPoints = points.filter((_, pointIdx) => assignments[pointIdx] === idx);\n    return {\n      id: idx,\n      name: clusterInfos[idx].name,\n      description: clusterInfos[idx].description,\n      color: clusterInfos[idx].color,\n      points: clusterPoints,\n      centroid: {\n        deviation: centroid.deviation * (maxDev - minDev) + minDev,\n        executionRate: centroid.executionRate * (maxExec - minExec) + minExec\n      }\n    };\n  });\n};\n\n// Identifica padrões de comportamento\nexport const identifyBehaviorPatterns = clusters => {\n  const patterns = [];\n\n  // Padrão eleitoral\n  const electoralClusters = clusters.filter(c => c.points.filter(p => p.isElectionYear).length > c.points.length * 0.6);\n  if (electoralClusters.length > 0) {\n    const avgDeviation = electoralClusters[0].centroid.deviation;\n    if (avgDeviation > 5) {\n      patterns.push(`Anos eleitorais tendem a ter aumento de ${avgDeviation.toFixed(1)}% no orçamento`);\n    }\n  }\n\n  // Padrão de crise\n  const crisisClusters = clusters.filter(c => c.centroid.deviation < -15);\n  if (crisisClusters.length > 0) {\n    patterns.push(`Identificados ${crisisClusters[0].points.length} anos com cortes severos (>15%)`);\n  }\n\n  // Padrão de subexecução\n  const subexecutionClusters = clusters.filter(c => c.centroid.executionRate < 70);\n  if (subexecutionClusters.length > 0) {\n    patterns.push(`${subexecutionClusters[0].points.length} anos com subexecução crítica (<70%)`);\n  }\n  return patterns;\n};","map":{"version":3,"names":["euclideanDistance","p1","p2","Math","sqrt","pow","deviation","executionRate","kMeansClustering","points","k","maxIterations","deviations","map","p","executionRates","minDev","min","maxDev","max","minExec","maxExec","normalizedPoints","normDeviation","normExecutionRate","centroids","firstPoint","floor","random","length","push","i","distances","minDist","c","maxDistIndex","indexOf","assignments","Array","fill","iter","newAssignments","JSON","stringify","clusterPoints","filter","_","idx","reduce","sum","clusterInfos","centroid","avgDeviation","avgExecution","name","description","color","pointIdx","id","identifyBehaviorPatterns","clusters","patterns","electoralClusters","isElectionYear","toFixed","crisisClusters","subexecutionClusters"],"sources":["/Users/gustavocarvalho/budget-dashboard/src/utils/clustering.ts"],"sourcesContent":["// Algoritmo K-means para clustering de comportamentos orçamentários\n\nexport interface ClusterPoint {\n  year: number;\n  value: number;\n  deviation: number; // Desvio da média\n  isElectionYear: boolean;\n  executionRate: number;\n}\n\nexport interface Cluster {\n  id: number;\n  name: string;\n  description: string;\n  color: string;\n  points: ClusterPoint[];\n  centroid: { deviation: number; executionRate: number };\n}\n\n// Calcula distância euclidiana entre dois pontos\nconst euclideanDistance = (\n  p1: { deviation: number; executionRate: number },\n  p2: { deviation: number; executionRate: number }\n): number => {\n  return Math.sqrt(\n    Math.pow(p1.deviation - p2.deviation, 2) +\n    Math.pow(p1.executionRate - p2.executionRate, 2)\n  );\n};\n\n// Algoritmo K-means\nexport const kMeansClustering = (\n  points: ClusterPoint[],\n  k: number = 4,\n  maxIterations: number = 100\n): Cluster[] => {\n  // Normaliza os dados (0-1) para melhor clustering\n  const deviations = points.map(p => p.deviation);\n  const executionRates = points.map(p => p.executionRate);\n\n  const minDev = Math.min(...deviations);\n  const maxDev = Math.max(...deviations);\n  const minExec = Math.min(...executionRates);\n  const maxExec = Math.max(...executionRates);\n\n  const normalizedPoints = points.map(p => ({\n    ...p,\n    normDeviation: (p.deviation - minDev) / (maxDev - minDev || 1),\n    normExecutionRate: (p.executionRate - minExec) / (maxExec - minExec || 1)\n  }));\n\n  // Inicializa centroides (k-means++)\n  const centroids: Array<{ deviation: number; executionRate: number }> = [];\n\n  // Primeiro centroide aleatório\n  const firstPoint = normalizedPoints[Math.floor(Math.random() * normalizedPoints.length)];\n  centroids.push({\n    deviation: firstPoint.normDeviation,\n    executionRate: firstPoint.normExecutionRate\n  });\n\n  // Próximos centroides: escolhe pontos mais distantes\n  for (let i = 1; i < k; i++) {\n    const distances = normalizedPoints.map(p => {\n      const minDist = Math.min(...centroids.map(c =>\n        euclideanDistance(\n          { deviation: p.normDeviation, executionRate: p.normExecutionRate },\n          c\n        )\n      ));\n      return minDist;\n    });\n\n    const maxDistIndex = distances.indexOf(Math.max(...distances));\n    centroids.push({\n      deviation: normalizedPoints[maxDistIndex].normDeviation,\n      executionRate: normalizedPoints[maxDistIndex].normExecutionRate\n    });\n  }\n\n  // Iterações K-means\n  let assignments = new Array(points.length).fill(0);\n\n  for (let iter = 0; iter < maxIterations; iter++) {\n    // Atribui pontos aos clusters mais próximos\n    const newAssignments = normalizedPoints.map(p => {\n      const distances = centroids.map(c =>\n        euclideanDistance(\n          { deviation: p.normDeviation, executionRate: p.normExecutionRate },\n          c\n        )\n      );\n      return distances.indexOf(Math.min(...distances));\n    });\n\n    // Verifica convergência\n    if (JSON.stringify(assignments) === JSON.stringify(newAssignments)) {\n      break;\n    }\n    assignments = newAssignments;\n\n    // Recalcula centroides\n    for (let i = 0; i < k; i++) {\n      const clusterPoints = normalizedPoints.filter((_, idx) => assignments[idx] === i);\n      if (clusterPoints.length > 0) {\n        centroids[i] = {\n          deviation: clusterPoints.reduce((sum, p) => sum + p.normDeviation, 0) / clusterPoints.length,\n          executionRate: clusterPoints.reduce((sum, p) => sum + p.normExecutionRate, 0) / clusterPoints.length\n        };\n      }\n    }\n  }\n\n  // Nomeia e caracteriza clusters baseado nos centroides\n  const clusterInfos = centroids.map((centroid, idx) => {\n    const avgDeviation = centroid.deviation * (maxDev - minDev) + minDev;\n    const avgExecution = centroid.executionRate * (maxExec - minExec) + minExec;\n\n    let name = '';\n    let description = '';\n    let color = '';\n\n    if (avgDeviation > 10 && avgExecution > 80) {\n      name = 'Expansão com Alta Execução';\n      description = 'Anos com aumento orçamentário e execução eficiente';\n      color = '#10b981'; // Verde\n    } else if (avgDeviation > 10 && avgExecution <= 80) {\n      name = 'Expansão com Subexecução';\n      description = 'Anos eleitorais com aumento de verba mas execução baixa';\n      color = '#f59e0b'; // Amarelo\n    } else if (avgDeviation < -10) {\n      name = 'Crise/Corte';\n      description = 'Períodos de redução orçamentária significativa';\n      color = '#ef4444'; // Vermelho\n    } else {\n      name = 'Comportamento Normal';\n      description = 'Execução dentro da normalidade estatística';\n      color = '#3b82f6'; // Azul\n    }\n\n    return { name, description, color };\n  });\n\n  // Cria clusters finais\n  return centroids.map((centroid, idx) => {\n    const clusterPoints = points.filter((_, pointIdx) => assignments[pointIdx] === idx);\n\n    return {\n      id: idx,\n      name: clusterInfos[idx].name,\n      description: clusterInfos[idx].description,\n      color: clusterInfos[idx].color,\n      points: clusterPoints,\n      centroid: {\n        deviation: centroid.deviation * (maxDev - minDev) + minDev,\n        executionRate: centroid.executionRate * (maxExec - minExec) + minExec\n      }\n    };\n  });\n};\n\n// Identifica padrões de comportamento\nexport const identifyBehaviorPatterns = (clusters: Cluster[]): string[] => {\n  const patterns: string[] = [];\n\n  // Padrão eleitoral\n  const electoralClusters = clusters.filter(c =>\n    c.points.filter(p => p.isElectionYear).length > c.points.length * 0.6\n  );\n  if (electoralClusters.length > 0) {\n    const avgDeviation = electoralClusters[0].centroid.deviation;\n    if (avgDeviation > 5) {\n      patterns.push(`Anos eleitorais tendem a ter aumento de ${avgDeviation.toFixed(1)}% no orçamento`);\n    }\n  }\n\n  // Padrão de crise\n  const crisisClusters = clusters.filter(c => c.centroid.deviation < -15);\n  if (crisisClusters.length > 0) {\n    patterns.push(`Identificados ${crisisClusters[0].points.length} anos com cortes severos (>15%)`);\n  }\n\n  // Padrão de subexecução\n  const subexecutionClusters = clusters.filter(c => c.centroid.executionRate < 70);\n  if (subexecutionClusters.length > 0) {\n    patterns.push(`${subexecutionClusters[0].points.length} anos com subexecução crítica (<70%)`);\n  }\n\n  return patterns;\n};\n"],"mappings":"AAAA;;AAmBA;AACA,MAAMA,iBAAiB,GAAGA,CACxBC,EAAgD,EAChDC,EAAgD,KACrC;EACX,OAAOC,IAAI,CAACC,IAAI,CACdD,IAAI,CAACE,GAAG,CAACJ,EAAE,CAACK,SAAS,GAAGJ,EAAE,CAACI,SAAS,EAAE,CAAC,CAAC,GACxCH,IAAI,CAACE,GAAG,CAACJ,EAAE,CAACM,aAAa,GAAGL,EAAE,CAACK,aAAa,EAAE,CAAC,CACjD,CAAC;AACH,CAAC;;AAED;AACA,OAAO,MAAMC,gBAAgB,GAAGA,CAC9BC,MAAsB,EACtBC,CAAS,GAAG,CAAC,EACbC,aAAqB,GAAG,GAAG,KACb;EACd;EACA,MAAMC,UAAU,GAAGH,MAAM,CAACI,GAAG,CAACC,CAAC,IAAIA,CAAC,CAACR,SAAS,CAAC;EAC/C,MAAMS,cAAc,GAAGN,MAAM,CAACI,GAAG,CAACC,CAAC,IAAIA,CAAC,CAACP,aAAa,CAAC;EAEvD,MAAMS,MAAM,GAAGb,IAAI,CAACc,GAAG,CAAC,GAAGL,UAAU,CAAC;EACtC,MAAMM,MAAM,GAAGf,IAAI,CAACgB,GAAG,CAAC,GAAGP,UAAU,CAAC;EACtC,MAAMQ,OAAO,GAAGjB,IAAI,CAACc,GAAG,CAAC,GAAGF,cAAc,CAAC;EAC3C,MAAMM,OAAO,GAAGlB,IAAI,CAACgB,GAAG,CAAC,GAAGJ,cAAc,CAAC;EAE3C,MAAMO,gBAAgB,GAAGb,MAAM,CAACI,GAAG,CAACC,CAAC,KAAK;IACxC,GAAGA,CAAC;IACJS,aAAa,EAAE,CAACT,CAAC,CAACR,SAAS,GAAGU,MAAM,KAAKE,MAAM,GAAGF,MAAM,IAAI,CAAC,CAAC;IAC9DQ,iBAAiB,EAAE,CAACV,CAAC,CAACP,aAAa,GAAGa,OAAO,KAAKC,OAAO,GAAGD,OAAO,IAAI,CAAC;EAC1E,CAAC,CAAC,CAAC;;EAEH;EACA,MAAMK,SAA8D,GAAG,EAAE;;EAEzE;EACA,MAAMC,UAAU,GAAGJ,gBAAgB,CAACnB,IAAI,CAACwB,KAAK,CAACxB,IAAI,CAACyB,MAAM,CAAC,CAAC,GAAGN,gBAAgB,CAACO,MAAM,CAAC,CAAC;EACxFJ,SAAS,CAACK,IAAI,CAAC;IACbxB,SAAS,EAAEoB,UAAU,CAACH,aAAa;IACnChB,aAAa,EAAEmB,UAAU,CAACF;EAC5B,CAAC,CAAC;;EAEF;EACA,KAAK,IAAIO,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGrB,CAAC,EAAEqB,CAAC,EAAE,EAAE;IAC1B,MAAMC,SAAS,GAAGV,gBAAgB,CAACT,GAAG,CAACC,CAAC,IAAI;MAC1C,MAAMmB,OAAO,GAAG9B,IAAI,CAACc,GAAG,CAAC,GAAGQ,SAAS,CAACZ,GAAG,CAACqB,CAAC,IACzClC,iBAAiB,CACf;QAAEM,SAAS,EAAEQ,CAAC,CAACS,aAAa;QAAEhB,aAAa,EAAEO,CAAC,CAACU;MAAkB,CAAC,EAClEU,CACF,CACF,CAAC,CAAC;MACF,OAAOD,OAAO;IAChB,CAAC,CAAC;IAEF,MAAME,YAAY,GAAGH,SAAS,CAACI,OAAO,CAACjC,IAAI,CAACgB,GAAG,CAAC,GAAGa,SAAS,CAAC,CAAC;IAC9DP,SAAS,CAACK,IAAI,CAAC;MACbxB,SAAS,EAAEgB,gBAAgB,CAACa,YAAY,CAAC,CAACZ,aAAa;MACvDhB,aAAa,EAAEe,gBAAgB,CAACa,YAAY,CAAC,CAACX;IAChD,CAAC,CAAC;EACJ;;EAEA;EACA,IAAIa,WAAW,GAAG,IAAIC,KAAK,CAAC7B,MAAM,CAACoB,MAAM,CAAC,CAACU,IAAI,CAAC,CAAC,CAAC;EAElD,KAAK,IAAIC,IAAI,GAAG,CAAC,EAAEA,IAAI,GAAG7B,aAAa,EAAE6B,IAAI,EAAE,EAAE;IAC/C;IACA,MAAMC,cAAc,GAAGnB,gBAAgB,CAACT,GAAG,CAACC,CAAC,IAAI;MAC/C,MAAMkB,SAAS,GAAGP,SAAS,CAACZ,GAAG,CAACqB,CAAC,IAC/BlC,iBAAiB,CACf;QAAEM,SAAS,EAAEQ,CAAC,CAACS,aAAa;QAAEhB,aAAa,EAAEO,CAAC,CAACU;MAAkB,CAAC,EAClEU,CACF,CACF,CAAC;MACD,OAAOF,SAAS,CAACI,OAAO,CAACjC,IAAI,CAACc,GAAG,CAAC,GAAGe,SAAS,CAAC,CAAC;IAClD,CAAC,CAAC;;IAEF;IACA,IAAIU,IAAI,CAACC,SAAS,CAACN,WAAW,CAAC,KAAKK,IAAI,CAACC,SAAS,CAACF,cAAc,CAAC,EAAE;MAClE;IACF;IACAJ,WAAW,GAAGI,cAAc;;IAE5B;IACA,KAAK,IAAIV,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGrB,CAAC,EAAEqB,CAAC,EAAE,EAAE;MAC1B,MAAMa,aAAa,GAAGtB,gBAAgB,CAACuB,MAAM,CAAC,CAACC,CAAC,EAAEC,GAAG,KAAKV,WAAW,CAACU,GAAG,CAAC,KAAKhB,CAAC,CAAC;MACjF,IAAIa,aAAa,CAACf,MAAM,GAAG,CAAC,EAAE;QAC5BJ,SAAS,CAACM,CAAC,CAAC,GAAG;UACbzB,SAAS,EAAEsC,aAAa,CAACI,MAAM,CAAC,CAACC,GAAG,EAAEnC,CAAC,KAAKmC,GAAG,GAAGnC,CAAC,CAACS,aAAa,EAAE,CAAC,CAAC,GAAGqB,aAAa,CAACf,MAAM;UAC5FtB,aAAa,EAAEqC,aAAa,CAACI,MAAM,CAAC,CAACC,GAAG,EAAEnC,CAAC,KAAKmC,GAAG,GAAGnC,CAAC,CAACU,iBAAiB,EAAE,CAAC,CAAC,GAAGoB,aAAa,CAACf;QAChG,CAAC;MACH;IACF;EACF;;EAEA;EACA,MAAMqB,YAAY,GAAGzB,SAAS,CAACZ,GAAG,CAAC,CAACsC,QAAQ,EAAEJ,GAAG,KAAK;IACpD,MAAMK,YAAY,GAAGD,QAAQ,CAAC7C,SAAS,IAAIY,MAAM,GAAGF,MAAM,CAAC,GAAGA,MAAM;IACpE,MAAMqC,YAAY,GAAGF,QAAQ,CAAC5C,aAAa,IAAIc,OAAO,GAAGD,OAAO,CAAC,GAAGA,OAAO;IAE3E,IAAIkC,IAAI,GAAG,EAAE;IACb,IAAIC,WAAW,GAAG,EAAE;IACpB,IAAIC,KAAK,GAAG,EAAE;IAEd,IAAIJ,YAAY,GAAG,EAAE,IAAIC,YAAY,GAAG,EAAE,EAAE;MAC1CC,IAAI,GAAG,4BAA4B;MACnCC,WAAW,GAAG,oDAAoD;MAClEC,KAAK,GAAG,SAAS,CAAC,CAAC;IACrB,CAAC,MAAM,IAAIJ,YAAY,GAAG,EAAE,IAAIC,YAAY,IAAI,EAAE,EAAE;MAClDC,IAAI,GAAG,0BAA0B;MACjCC,WAAW,GAAG,yDAAyD;MACvEC,KAAK,GAAG,SAAS,CAAC,CAAC;IACrB,CAAC,MAAM,IAAIJ,YAAY,GAAG,CAAC,EAAE,EAAE;MAC7BE,IAAI,GAAG,aAAa;MACpBC,WAAW,GAAG,gDAAgD;MAC9DC,KAAK,GAAG,SAAS,CAAC,CAAC;IACrB,CAAC,MAAM;MACLF,IAAI,GAAG,sBAAsB;MAC7BC,WAAW,GAAG,4CAA4C;MAC1DC,KAAK,GAAG,SAAS,CAAC,CAAC;IACrB;IAEA,OAAO;MAAEF,IAAI;MAAEC,WAAW;MAAEC;IAAM,CAAC;EACrC,CAAC,CAAC;;EAEF;EACA,OAAO/B,SAAS,CAACZ,GAAG,CAAC,CAACsC,QAAQ,EAAEJ,GAAG,KAAK;IACtC,MAAMH,aAAa,GAAGnC,MAAM,CAACoC,MAAM,CAAC,CAACC,CAAC,EAAEW,QAAQ,KAAKpB,WAAW,CAACoB,QAAQ,CAAC,KAAKV,GAAG,CAAC;IAEnF,OAAO;MACLW,EAAE,EAAEX,GAAG;MACPO,IAAI,EAAEJ,YAAY,CAACH,GAAG,CAAC,CAACO,IAAI;MAC5BC,WAAW,EAAEL,YAAY,CAACH,GAAG,CAAC,CAACQ,WAAW;MAC1CC,KAAK,EAAEN,YAAY,CAACH,GAAG,CAAC,CAACS,KAAK;MAC9B/C,MAAM,EAAEmC,aAAa;MACrBO,QAAQ,EAAE;QACR7C,SAAS,EAAE6C,QAAQ,CAAC7C,SAAS,IAAIY,MAAM,GAAGF,MAAM,CAAC,GAAGA,MAAM;QAC1DT,aAAa,EAAE4C,QAAQ,CAAC5C,aAAa,IAAIc,OAAO,GAAGD,OAAO,CAAC,GAAGA;MAChE;IACF,CAAC;EACH,CAAC,CAAC;AACJ,CAAC;;AAED;AACA,OAAO,MAAMuC,wBAAwB,GAAIC,QAAmB,IAAe;EACzE,MAAMC,QAAkB,GAAG,EAAE;;EAE7B;EACA,MAAMC,iBAAiB,GAAGF,QAAQ,CAACf,MAAM,CAACX,CAAC,IACzCA,CAAC,CAACzB,MAAM,CAACoC,MAAM,CAAC/B,CAAC,IAAIA,CAAC,CAACiD,cAAc,CAAC,CAAClC,MAAM,GAAGK,CAAC,CAACzB,MAAM,CAACoB,MAAM,GAAG,GACpE,CAAC;EACD,IAAIiC,iBAAiB,CAACjC,MAAM,GAAG,CAAC,EAAE;IAChC,MAAMuB,YAAY,GAAGU,iBAAiB,CAAC,CAAC,CAAC,CAACX,QAAQ,CAAC7C,SAAS;IAC5D,IAAI8C,YAAY,GAAG,CAAC,EAAE;MACpBS,QAAQ,CAAC/B,IAAI,CAAC,2CAA2CsB,YAAY,CAACY,OAAO,CAAC,CAAC,CAAC,gBAAgB,CAAC;IACnG;EACF;;EAEA;EACA,MAAMC,cAAc,GAAGL,QAAQ,CAACf,MAAM,CAACX,CAAC,IAAIA,CAAC,CAACiB,QAAQ,CAAC7C,SAAS,GAAG,CAAC,EAAE,CAAC;EACvE,IAAI2D,cAAc,CAACpC,MAAM,GAAG,CAAC,EAAE;IAC7BgC,QAAQ,CAAC/B,IAAI,CAAC,iBAAiBmC,cAAc,CAAC,CAAC,CAAC,CAACxD,MAAM,CAACoB,MAAM,iCAAiC,CAAC;EAClG;;EAEA;EACA,MAAMqC,oBAAoB,GAAGN,QAAQ,CAACf,MAAM,CAACX,CAAC,IAAIA,CAAC,CAACiB,QAAQ,CAAC5C,aAAa,GAAG,EAAE,CAAC;EAChF,IAAI2D,oBAAoB,CAACrC,MAAM,GAAG,CAAC,EAAE;IACnCgC,QAAQ,CAAC/B,IAAI,CAAC,GAAGoC,oBAAoB,CAAC,CAAC,CAAC,CAACzD,MAAM,CAACoB,MAAM,sCAAsC,CAAC;EAC/F;EAEA,OAAOgC,QAAQ;AACjB,CAAC","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}